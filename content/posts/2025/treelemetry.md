---
title: treelemetry
date: 2025-12-16
author: admin
category: Uncategorized
slug: treelemetry
status: published
save_as: 2025/12/16/treelemetry/index.html
url: 2025/12/16/treelemetry/
---

[![treelemetry graph of water level (min/max/mean) and temp/humidity over the last 24h](/static/2025/12/treelemetry2.png)](https://treelemetry.tomlee.space)

The [blog update](/2025/12/15/a-fresh-coat-of-paint/) is not the only project that AI coding has allowed me to pursue with wild abandon. Three years ago I bought a small rangefinding module from Adafruit, attached it to a wifi-capable microcontroller, and pointed it at the water in my Christmas tree stand. Since then, adding a new layer of technical complexity has become a cherished holiday tradition.

The sensor is worth dwelling on, a lovely example of the silicon miracles that now litter our households. [Adafruit sells the full module for about fifteen bucks](https://learn.adafruit.com/adafruit-vl6180x-time-of-flight-micro-lidar-distance-sensor-breakout), and it's not much bigger than a thumbprint. But even that is mostly filler, mere support circuitry in service of the [VL6180X](https://www.st.com/en/imaging-and-photonics-solutions/vl6180x.html#overview), a tiny black spec that spits out pulses of infrared light and reports back the distance to the first thing they bounce off of, at a resolution of 1 millimeter and a maximum range of 10 centimeters. The VL6180X itself can be had for less than $4, but it's so tiny that few hobbyists will find it very convenient, hence Adafruit's role.

You might wonder: how on earth can this thing do what it does? Light travels at 3x10E8 meters per second. Convert to millimeters by bumping that 8 to 11. Divide a second of time into 3x10E11 parts--that's how long it takes for light to travel that far. A microcontroller clock would have to run in the terahertz range to see this distinction. Nobody knows how to build a computer that fast, much less sell it for $4.

So instead these gadgets measure the time difference been pulse and reception using specialized circuitry that makes it possible to calculate the relative timing of signals. Their ancestors are [acoustic delay lines](https://en.wikipedia.org/wiki/Delay-line_memory), an evocative piece of hardware from the early days of radar, when the idea of keeping information in memory was still impossibly difficult. Instead, a signal could be preserved by catching it in a slower medium and feeding it energy to sustain it, like a kid with a jar full of caterpillars and leaves. An incoming radio signal would be connected to a long tube full of mercury, or quartz, or who knows what, with a speaker at one end and a microphone at the other. The speaker would holler the signal out, and it would inch its way down the medium, then be collected by the microphone, then amplified and fed back to the speaker. This loop could be tapped when needed to (for example) make a subtractive comparison with an incoming radar signal, which could filter out all the stationary objects present in each bounce, leaving only the dots belonging to the Luftwaffe or whoever else.

The VL6180X's datasheet does not disclose its secrets, but this sensor likely works with a less toxically mercury-filled version of the same idea: a linear cascade of relatively slow-switching silicon parts, which is ignited like the fuse to a bundle of Looney Tunes dynamite whenever an infrared pulse is emitted. The photodetector that sees the bounce--in a furious, hair-trigger electrical stampede provided by a different but also fascinating component--is connected to circuitry that instantly freezes the progression of the fuse so that its length can be measured at the microcontroller brain's sluggish rate of thought. This is done many times, fabulously quickly, to reduce the noisiness of the measurement, and then adjusted against calibrations of the cascade's imperfectly-homogenous speed and its response to temperature differences, which were measured and recorded at the production facility.

A tiny miracle! Honestly, when I bought it I didn't even know if infrared light would bounce off of the surface of the water in the dish. But it does. My microcontroller can read the resulting measurement in a highly civilized electronic dialect, and it reports it over wifi to a server next to my furnace using a protocol called MQTT. MQTT is designed to receive reports from sensors and echo them out to as many listeners as have signed up, and to do it with very little delay--a classic pub/sub configuration. I built a little piece of software that would listen for measurements, aggregate them into various time periods, and upload a web-accessible file of them to a set location in Amazon S3 a couple of times per minute.

All this had been running for two years, and visualized in some unappealing graphs like [this](https://sbma44.github.io/tree-analytics/). I also [added a software guard dog](https://github.com/sbma44/xmas_tree_alarm) that monitors the MQTT measurements and, if the water dipped too low, turns our [fancy, wifi-enabled Christmas tree lights red](https://twinkly.com/collections/christmas-lighting).

As part of that alarm system, I moved the data collection and uploading stuff off of my basement's humble Raspberry Pi. The Pi is capable enough for this, but its storage medium is a flash memory, and every write-intensive operation brings its death closer. Two autumns ago I bought [a bargain basement NAS](https://www.terra-master.com/), which I cannot really recommend but which is capable of running x86 Docker containers (but not any Docker orchestration software without tearing out the whole busybox-based operating system, which I don't care to do). So I dockerized the logging and alarm software, then redid it all this year with DuckDB.

The uploader is separate, but should probably be rolled together with the uploader. It now includes some statistical analysis to find periods of monotonic distance increase--these reflect when the tree is "drinking" between water refills--and calculates their best-fit slope, a proxy for water use (the water dish's geometry isn't perfectly uniform). This part of the system is especially imperfect, particularly in the early hours of a new "drinking" interval, but it's much improved from what came before thanks to some suggestions from ChatGPT that exceeded my own stat knowledge. And I think it's good enough to confirm changes in the rate of water consumption, which will presumably signal that the tree is fully dead and drying out. Most of the outliers in that graph reflect periods where I was manually adjusting the sensor position to account for a spill or some other uninteresting physical problem.

To really gild the lilly, this year I added a few more sensors. I first heard about [YoLink's suite of home automation products](https://shop.yosmart.com/collections/all?irclickid=15SwLBVJ4xycRDxxyTRzOXegUkpQFs25W3nnSA0&sharedid=&irpid=3311071&irgwc=1&afsrc=1&gad_source=1&gad_campaignid=23346232226&gbraid=0AAAABCNtJ7avLgJ2peNV54cu43ucrhI9O&gclid=Cj0KCQiAo4TKBhDRARIsAGW29bd5HkppIRmNiOc-PmBVzqJqYrBZFraCt7ngNWddkX1wXGBLnAp-10EaAvGnEALw_wcB) on the [Accidental Tech Podcast](https://atp.fm), but hadn't been ready to take the plunge. My only real need for their stuff is leak detectors (mine are worryingly internet-incapable) and environmental sensing, which is [something I already built](/2022/02/01/notes-on-becoming-a-home-automation-dad/).

The YoLink system does offer advantages, though. My bespoke environmental system uses Bluetooth temperature/humidity sensors, which passively emit the household's HVAC conditions as BT chirps. These are picked up by some ESP32 microcontrollers running software I wrote, which decodes the chirps and reports the detected values to my MQTT server over wifi. But Bluetooth doesn't go far, so chirp collection requires me to scatter ESP32s around my house in locations with access to power. The LR2032 coin cell batteries powering the sensors don't go far either, forcing me to swap out dead cells once or twice a year for every room. And of course I never implemented low-battery detection, or a mechanism for telling when a temperature reading has become stale (if a sensor dies, the echo of its last report remains in my phone's Homekit screen forever).

YoLink has solved all of these problems, which, I must emphasize, are not imaginary. The sensors take AA batteries. They speak LoRa, a long-range low-power flavor of RF that traipses through walls and can go a full kilometer before fully dissolving. This means that only one hub is necessary, and YoLink's plugs in wherever, capturing those whispers and reporting them over wifi and on to the cloud. That last part is a minor disappointment: I am sure the service will betray its customers eventually, they all do. But YoLink hasn't yet--all the cloud stuff is free to access--and hopefully their $200 local API hub will still be on sale when they do. In the meantime, one can access their API [pretty easily](https://github.com/sbma44/yolink-api/tree/sbma44-more-docs), and even subscribe to their own MQTT server.

[![treelemetry statistical modules showing water level, time to refill, environmental readings](/static/2025/12/treelemetry.png)](https://treelemetry.tomlee.space)

I nestled YoLink sensors into our Christmas tree's lower branches, which measure air temperature and humidity, plus the temperature of the water in the dish. Why not! The data logger now speaks to both MQTT servers, mine and theirs. The uploader uses AWS CDK to create properly secure credentials for its uploading.

And, of course, [the web UI has been redone](https://treelemetry.tomlee.space). The segment slope graph could use some work, and I wouldn't say I *love* the overall aesthetic. But this is clearly a collection of very silly ideas, not worth really laboring over. I spent perhaps $15 in Cursor overage fees to get all this out, and in the process I learned some new things. I moved from `pip` to `uv`, and `troposphere` to `CDK`, and `sqlite` to `duckdb`. I stopped being scared of creating new CNAMEs for Github Pages sites. Some of the new statistical ideas might stick with me, though probably not. And I managed to customize [Bradly Feeley's Christmas light adornment](https://github.com/bradly/christmas-lights.js/tree/main) without a robot's help, preserving at least a shred of dignity. The code for all this is [here](https://github.com/sbma44/treelemetry).

Certainly, I can understand why LLMs are a source of sadness for many software developers. But for this, at least, my experience of them has been delightful, a way to refresh my knowledge of current practices and extend my reach.

My earliest blog posts on this site are full of my enrapturement over technical detail. The excitement of figuring out a puzzle was immense, and I took great pride in it. I can still feel parts of sensation--this post may be proof of it. But I have also come to understand how disposable technology is (who else remembers XSPF, or the NYU Coral Cache?) and how often new ideas or details within the field are not as interesting as I might once have thought.

With age, the truly mighty conceptual monuments (obviously including Christmas tree water level monitoring) have become easier for me to pick out amidst the jumble of the horizon. The distance to reach them is often too vast to be worth traversing. Sometimes it's okay to admire them from a distance. But LLMs now occasionally let people like me vault over the expanse and see it all up close. I know that nobody likes tourists, but it's good to get out of the house.